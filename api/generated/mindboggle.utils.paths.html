<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mindboggle &mdash; Mindboggle</title>
    
    <link rel="stylesheet" href="../../_static/mindboggle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Mindboggle" href="../../index.html" />
  <HTML><head><title>Mindboggle</title>
  <meta http-equiv="Content-language" content="en">
  <meta name="description" content="Mindboggle">
  <meta name="keywords" content="Mindboggle, neuroimaging, brain imaging, python, neuroscience, labeling, parcellation, morphometry, shape analysis, MRI">
  <meta name="author" content="mailto:arno&#64;mindboggle.info">
  <meta name="dc.title" content="Mindboggle"> 
  <meta name="dc.creator.address" content="arno&#64;mindboggle.info">
  <meta name="dc.subject" content="Mindboggle">
  <meta name="dc.type" content="text.homepage.academic"> 
  <meta name="dc.format" content="text/html"> 
  <meta name="dc.identifier" content="http://mindboggle.info/">

  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <table>
  <tr>
   <td>

 <a href="../../index.html">
  <img src="../../shared/mindboggle_logo_small.jpg" alt="small mindboggle logo"  border="0" width="160"/></a>

   </td>
   <td>
    <table>
     <tr>
 <a style="padding: 20px 20px 20px 20px; color: #b07613; text-decoration: none; font-size: 32px"
  href="../../index.html">Mindboggle</a>
     </tr>
     <tr> <td height="18"></td>
     </tr>
     <tr>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="http://mindboggle.info/users/README.html">Software</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../data.html">Data</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../papers.html">Papers</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../people.html">People</a>
      </td>
     </tr>
    </table>
   </td>
  </tr>
 </table>
</div>
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="utils-paths">
<h1>utils.paths<a class="headerlink" href="#utils-paths" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-mindboggle.utils.paths">
<span id="module-utils-paths"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">utils.paths</span></tt><a class="headerlink" href="#module-mindboggle.utils.paths" title="Permalink to this headline">¶</a></h2>
<p>Curves, tracks, skeletons connecting surface mesh vertices.</p>
<dl class="docutils">
<dt>Authors:</dt>
<dd><ul class="first last simple">
<li>Arno Klein, 2012-2013  (<a class="reference external" href="mailto:arno&#37;&#52;&#48;mindboggle&#46;info">arno<span>&#64;</span>mindboggle<span>&#46;</span>info</a>)  <a class="reference external" href="http://binarybottle.com">http://binarybottle.com</a></li>
<li>Yrjo Hame, 2012  (<a class="reference external" href="mailto:yrjo&#46;hame&#37;&#52;&#48;gmail&#46;com">yrjo<span>&#46;</span>hame<span>&#64;</span>gmail<span>&#46;</span>com</a>)</li>
</ul>
</dd>
</dl>
<p>Copyright 2013,  Mindboggle team (<a class="reference external" href="http://mindboggle.info">http://mindboggle.info</a>), Apache v2.0 License</p>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mindboggle.utils.paths.connect_points_erosion">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">connect_points_erosion</tt><big>(</big><em>S</em>, <em>neighbor_lists</em>, <em>outer_anchors</em>, <em>inner_anchors=[]</em>, <em>values=[]</em>, <em>erode_ratio=0.1</em>, <em>erode_min_size=10</em>, <em>save_steps=[]</em>, <em>save_vtk=''</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.connect_points_erosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect mesh vertices with a skeleton of 1-vertex-thick curves by erosion.</p>
<p>This algorithm iteratively removes simple topological points and endpoints,
optionally in order of lowest to highest values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>S</strong> : numpy array of integers</p>
<blockquote>
<div><p>values for all vertices</p>
</div></blockquote>
<p><strong>outer_anchors</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices to connect</p>
</div></blockquote>
<p><strong>inner_anchors</strong> : list of integers</p>
<blockquote>
<div><p>more vertices to connect; they are removed if they result in endpoints</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>values</strong> : numpy array of floats</p>
<blockquote>
<div><p>values for S elements, to optionally remove points
in order of lowest to highest values</p>
</div></blockquote>
<p><strong>erode_ratio</strong> : float</p>
<blockquote>
<div><p>fraction of indices to test for removal at each iteration (if values)</p>
</div></blockquote>
<p><strong>erode_min_size</strong> : integer</p>
<blockquote>
<div><p>minimum number of vertices when considering erode_ratio</p>
</div></blockquote>
<p><strong>save_steps</strong> : list of integers (optional)</p>
<blockquote>
<div><p>iterations at which to save incremental VTK file</p>
</div></blockquote>
<p><strong>save_vtk</strong> : string</p>
<blockquote>
<div><p>name of VTK file to transfer incremental values (if save_steps)</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>skeleton</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices to vertices of skeleton</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract a skeleton to connect endpoints in a fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.compute</span> <span class="kn">import</span> <span class="n">median_abs_dev</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">find_max_values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">connect_points_erosion</span><span class="p">,</span> <span class="n">find_outer_anchors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curv_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.mean_curvature.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="p">,</span><span class="n">u2</span><span class="p">,</span><span class="n">u3</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">u4</span><span class="p">,</span> <span class="n">curvs</span><span class="p">,</span> <span class="n">u5</span><span class="p">,</span><span class="n">u6</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">curv_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;travel_depth_rescaled.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depths</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">curvs</span> <span class="o">*</span> <span class="n">depths</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">curv_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Outer anchors:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_separation</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outer_anchors</span><span class="p">,</span> <span class="n">tracks</span> <span class="o">=</span> <span class="n">find_outer_anchors</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                            <span class="n">values</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Inner anchors:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">median_abs_dev</span><span class="p">(</span><span class="n">values0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inner_anchors</span> <span class="o">=</span> <span class="n">find_max_values</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erode_ratio</span> <span class="o">=</span> <span class="mf">0.10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erode_min_size</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_steps</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#range(0,500,50)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_vtk</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">connect_points_erosion</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">outer_anchors</span><span class="p">,</span> <span class="n">inner_anchors</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">erode_ratio</span><span class="p">,</span> <span class="n">erode_min_size</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">save_steps</span><span class="p">,</span> <span class="n">save_vtk</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#if save_steps:  plot_surfaces(&#39;edge&#39;+str(save_steps[0])+&#39;.vtk&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write out vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">[</span><span class="n">skeleton</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">[</span><span class="n">outer_anchors</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">folds</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="s">&#39;connect_points_erosion.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">D</span><span class="p">,</span> <span class="s">&#39;skeleton&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;connect_points_erosion.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.paths.connect_points_hmmf">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">connect_points_hmmf</tt><big>(</big><em>indices_points</em>, <em>indices</em>, <em>L</em>, <em>neighbor_lists</em>, <em>wN_max=1.0</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.connect_points_hmmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect mesh vertices with a skeleton of 1-vertex-thick curves using HMMF.</p>
<p>The goal of this algorithm is to assign each vertex a locally optimal
Hidden Markov Measure Field (HMMF) value and to connect vertices according
to a cost function that penalizes vertices that do not have high likelihood
values and have HMMF values different than their neighbors.</p>
<p>We initialize the HMMF values with likelihood values normalized to the
interval (0.5, 1.0] (to guarantee correct topology) and take those values
that are greater than the likelihood threshold (1 for each anchor point).</p>
<p>We iteratively update each HMMF value if it is near the likelihood
threshold such that a H_step makes it cross the threshold,
and the vertex is a &#8220;simple point&#8221; (its addition/removal alters topology).</p>
<p>Parameters for computing the cost and cost gradients:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">wL</span></tt>: weight influence of likelihood on the cost function
<tt class="docutils literal"><span class="pre">wN</span></tt>: weight influence of neighbors on the cost function
<tt class="docutils literal"><span class="pre">H_step</span></tt>: the amount that the HMMF values are incremented</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices_points</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices to connect (should contain &gt; 1)</p>
</div></blockquote>
<p><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices through which to connect points</p>
</div></blockquote>
<p><strong>L</strong> : numpy array of floats</p>
<blockquote>
<div><p>likelihood values for all vertices in mesh</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>wN_max</strong> : float</p>
<blockquote>
<div><p>maximum neighborhood weight (trust prior more for smoother fundi)</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>skeleton</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices to vertices connecting the points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Connect vertices according to likelihood values in a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">read_scalars</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">read_faces_points</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">find_outer_anchors</span><span class="p">,</span> <span class="n">connect_points_hmmf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Get neighbor_lists, scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span> <span class="o">=</span> <span class="n">read_faces_points</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">folds</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Find endpoints:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_seeding_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;travel_depth_rescaled.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_seeding</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_seeding_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;likelihoods.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_separation</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keep</span><span class="p">,</span> <span class="n">tracks</span> <span class="o">=</span> <span class="n">find_outer_anchors</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">values_seeding</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wN_max</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">connect_points_hmmf</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">wN_max</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#S = connect_points_hmmf(keep, indices, values_seeding, neighbor_lists, wN_max)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skeleton</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skeleton</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="s">&#39;connect_points_hmmf.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">skeleton</span><span class="p">,</span> <span class="s">&#39;skeleton&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;connect_points_hmmf.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.paths.find_max_values">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">find_max_values</tt><big>(</big><em>points</em>, <em>values</em>, <em>min_separation=10</em>, <em>thr=0.5</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.find_max_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Find points with maximal values that are not too close together.</p>
<p>Steps</p>
<div class="highlight-python"><div class="highlight"><pre>1. Sort values and find values above the threshold.

2. Initialize special points with the maximum value,
   remove this value, and loop through the remaining high values.

3. If there are no nearby special points,
   assign the maximum value vertex as a special point.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : numpy array of floats</p>
<blockquote>
<div><p>coordinates for all vertices</p>
</div></blockquote>
<p><strong>values</strong> : list (or array) of integers</p>
<blockquote>
<div><p>values of some kind to maximize over for all vertices</p>
</div></blockquote>
<p><strong>min_separation</strong> : integer</p>
<blockquote>
<div><p>minimum number of edges between maximum value vertices</p>
</div></blockquote>
<p><strong>thr</strong> : float</p>
<blockquote>
<div><p>value threshold in [0,1]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>highest</strong> : list of integers</p>
<blockquote class="last">
<div><p>subset of surface mesh vertex indices with the highest values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.compute</span> <span class="kn">import</span> <span class="n">median_abs_dev</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">find_max_values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">likelihood_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;likelihoods.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">u3</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">u4</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">u5</span><span class="p">,</span> <span class="n">u6</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">likelihood_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_single_fold</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">plot_single_fold</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">fold_ID</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">indices_fold</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_ID</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">indices_not_fold</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">fold_ID</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">values</span><span class="p">[</span><span class="n">indices_not_fold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">fold_array</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">fold_array</span><span class="p">[</span><span class="n">indices_fold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="n">folds</span> <span class="o">=</span> <span class="n">fold_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_separation</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values0</span><span class="p">)</span> <span class="o">+</span> <span class="n">median_abs_dev</span><span class="p">(</span><span class="n">values0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">thr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">highest</span> <span class="o">=</span> <span class="n">find_max_values</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="n">highest</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">likelihood_file</span><span class="p">,</span> <span class="s">&#39;find_max_values.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">values</span><span class="p">,</span> <span class="s">&#39;find_max_values_in_folds&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;find_max_values.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.paths.find_outer_anchors">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">find_outer_anchors</tt><big>(</big><em>indices</em>, <em>neighbor_lists</em>, <em>values</em>, <em>values_seeding</em>, <em>min_separation=10</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.find_outer_anchors" title="Permalink to this definition">¶</a></dt>
<dd><p>Find vertices on the boundary of a surface mesh region that are the
endpoints to multiple, high-value tracks from the region&#8217;s center.</p>
<p>This algorithm propagates multiple tracks from seed vertices
at a given depth within a region of a surface mesh to the boundary
of the region (via the track_segments() function).
The tracks terminate at boundary vertices that can serve as endpoints
of fundus curves running along the depths of a fold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices of the vertices to segment (such as a fold in a surface mesh)</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>values</strong> : numpy array of floats</p>
<blockquote>
<div><p>values for all vertices (e.g., fundus likelihood values)</p>
</div></blockquote>
<p><strong>values_seeding</strong> : numpy array of floats</p>
<blockquote>
<div><p>values for all vertices to threshold for initial seeds</p>
</div></blockquote>
<p><strong>min_separation</strong> : integer</p>
<blockquote>
<div><p>minimum number of edges between anchor vertices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>endpoints</strong> : list of integers</p>
<blockquote>
<div><p>indices of surface mesh vertices that are endpoints</p>
</div></blockquote>
<p><strong>endtracks</strong> : list of lists of integers</p>
<blockquote class="last">
<div><p>indices to track vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Setup:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">find_outer_anchors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_seeding_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;travel_depth_rescaled.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_seeding</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_seeding_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;likelihoods.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_separation</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#---------------------------------------------------------------------</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract endpoints and their tracks from a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#---------------------------------------------------------------------</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">folds</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">endpoints</span><span class="p">,</span> <span class="n">endtracks</span> <span class="o">=</span> <span class="n">find_outer_anchors</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">values</span><span class="p">,</span> <span class="n">values_seeding</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View results atop values:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">endtracks</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="n">all_tracks</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.03</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="n">all_tracks</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;endpoints.vtk&#39;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">values</span><span class="p">,</span> <span class="s">&#39;endpoints_on_values_in_fold&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;endpoints.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#---------------------------------------------------------------------</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract endpoints and their tracks on every fold in a hemisphere:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#---------------------------------------------------------------------</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;subfolds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nfolds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fold_numbers</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_endpoints</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_tracks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ifold</span><span class="p">,</span> <span class="n">fold_number</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fold_numbers</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Fold {0} ({1} of {2})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fold_number</span><span class="p">),</span> <span class="n">ifold</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfolds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_size</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">endpoints</span><span class="p">,</span> <span class="n">endtracks</span> <span class="o">=</span> <span class="n">find_outer_anchors</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="n">values</span><span class="p">,</span> <span class="n">values_seeding</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">all_endpoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">all_tracks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">endtracks</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">[</span><span class="n">all_tracks</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">[</span><span class="n">all_endpoints</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to VTK file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="s">&#39;find_outer_anchors.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">P</span><span class="p">,</span> <span class="s">&#39;tracks_endpoints_on_folds&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;find_outer_anchors.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.paths.smooth_skeleton">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">smooth_skeleton</tt><big>(</big><em>skeletons</em>, <em>bounds</em>, <em>vtk_file</em>, <em>likelihoods</em>, <em>wN_max=1.0</em>, <em>erode_again=False</em>, <em>save_file=False</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.smooth_skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth skeleton by dilation followed by connect_points_hmmf().</p>
<dl class="docutils">
<dt>Steps ::</dt>
<dd><ol class="first last arabic simple">
<li>Segment skeleton into separate sets of connected vertices.</li>
<li>For each skeleton segment, extract endpoints.</li>
<li>Dilate skeleton segment.</li>
<li>Connect endpoints through dilated segment by connect_points_hmmf().</li>
<li>Store smoothed output from #4.</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>skeletons</strong> : list of integers</p>
<blockquote>
<div><p>skeleton number for each vertex</p>
</div></blockquote>
<p><strong>bounds</strong> : list of integers</p>
<blockquote>
<div><p>region number for each vertex; constrains smoothed skeletons</p>
</div></blockquote>
<p><strong>vtk_file</strong> : string</p>
<blockquote>
<div><p>file from which to extract neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>likelihoods</strong> : list of integers</p>
<blockquote>
<div><p>fundus likelihood value for each vertex</p>
</div></blockquote>
<p><strong>wN_max</strong> : float</p>
<blockquote>
<div><p>maximum neighborhood weight (trust prior more for smoother skeletons)</p>
</div></blockquote>
<p><strong>erode_again</strong> : Boolean</p>
<blockquote>
<div><p>smooth skeleton?</p>
</div></blockquote>
<p><strong>save_file</strong> : Boolean</p>
<blockquote>
<div><p>save output VTK file?</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>skeletons</strong> : list of integers</p>
<blockquote>
<div><p>skeleton numbers for all vertices</p>
</div></blockquote>
<p><strong>n_skeletons</strong> :  integer</p>
<blockquote>
<div><p>number of skeletons</p>
</div></blockquote>
<p><strong>skeletons_file</strong> : string (if save_file)</p>
<blockquote class="last">
<div><p>name of output VTK file with skeleton numbers</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract fundus from one or more folds:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">single_fold</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">smooth_skeleton</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">likelihoods_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;likelihoods.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">likelihoods</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">likelihoods_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.mean_curvature.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skeletons_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;fundi.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skeletons</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">skeletons_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">single_fold</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">fold_number</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#11</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">bounds</span><span class="p">[</span><span class="n">bounds</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wN_max</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erode_again</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_file</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smooth_skeletons</span><span class="p">,</span> <span class="n">n_skeletons</span><span class="p">,</span> <span class="n">skeletons_file</span> <span class="o">=</span> <span class="n">smooth_skeleton</span><span class="p">(</span><span class="n">skeletons</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">bounds</span><span class="p">,</span> <span class="n">vtk_file</span><span class="p">,</span> <span class="n">likelihoods</span><span class="p">,</span> <span class="n">wN_max</span><span class="p">,</span> <span class="n">erode_again</span><span class="p">,</span> <span class="n">save_file</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="n">skeletons_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.paths.track_segments">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">track_segments</tt><big>(</big><em>seed</em>, <em>segments</em>, <em>neighbor_lists</em>, <em>values</em>, <em>sink</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.track_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a track from a seed vertex through concentric segments of a mesh.</p>
<p>This function builds a track from an initial seed vertex through
concentric segments along high-value vertices of a surface mesh
optionally terminating at any of a set of sink vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : integer</p>
<blockquote>
<div><p>index to initial seed vertex from which to grow a track</p>
</div></blockquote>
<p><strong>segments</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices to vertices for each concentric segment</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>values</strong> : numpy array of floats</p>
<blockquote>
<div><p>values for all vertices that help to guide a track</p>
</div></blockquote>
<p><strong>sink</strong> : list of integers</p>
<blockquote>
<div><p>indices for vertices that end a track</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>track</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices of ordered vertices for a single track</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Track from deepest point in a fold to its boundary:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">segment_rings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">track_segments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;likelihoods.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">folds</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">indices</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">segment_rings</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract boundary:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">borders</span><span class="p">,</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)),</span> <span class="n">D</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">track</span> <span class="o">=</span> <span class="n">track_segments</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">borders</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">[</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;track.vtk&#39;</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="s">&#39;track&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;track.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.paths.track_values">
<tt class="descclassname">mindboggle.utils.paths.</tt><tt class="descname">track_values</tt><big>(</big><em>seed</em>, <em>indices</em>, <em>neighbor_lists</em>, <em>values</em>, <em>sink=[]</em><big>)</big><a class="headerlink" href="#mindboggle.utils.paths.track_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a track from a seed vertex along increasing vertex values of a mesh.</p>
<p>This function builds a track from an initial seed vertex through
increasing value vertices of a surface mesh, optionally terminating
at any of a set of sink vertices.</p>
<p>NOTE :: Untested!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : integer</p>
<blockquote>
<div><p>index to initial seed vertex from which to grow a track</p>
</div></blockquote>
<p><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices through which to connect points</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>values</strong> : numpy array of floats</p>
<blockquote>
<div><p>values for all vertices that help to guide a track</p>
</div></blockquote>
<p><strong>sink</strong> : list of integers</p>
<blockquote>
<div><p>indices for vertices that end a track (optional)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>track</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices of ordered vertices for a single track</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Track from deepest point in a fold to its boundary:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.paths</span> <span class="kn">import</span> <span class="n">track_values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;likelihoods.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.travel_depth.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;fold11.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">fold_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Start from initial track points on boundary of a thresholded indices:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">18267</span><span class="p">,</span> <span class="mi">38339</span><span class="p">,</span> <span class="mi">39689</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">seeds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">track</span> <span class="o">=</span> <span class="n">track_values</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">sink</span><span class="o">=</span><span class="p">[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">[</span><span class="n">track</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">[</span><span class="n">seed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;track.vtk&#39;</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="s">&#39;track&#39;</span><span class="p">,</span> <span class="n">fold</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;track.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
<!-- Google Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-693862-13");
pageTracker._trackPageview();
} catch(err) {}
</script>

  </body>
</html>