<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mindboggle &mdash; Mindboggle</title>
    
    <link rel="stylesheet" href="../../_static/mindboggle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Mindboggle" href="../../index.html" />
  <HTML><head><title>Mindboggle</title>
  <meta http-equiv="Content-language" content="en">
  <meta name="description" content="Mindboggle">
  <meta name="keywords" content="Mindboggle, neuroimaging, brain imaging, python, neuroscience, labeling, parcellation, morphometry, shape analysis, MRI">
  <meta name="author" content="mailto:arno&#64;mindboggle.info">
  <meta name="dc.title" content="Mindboggle"> 
  <meta name="dc.creator.address" content="arno&#64;mindboggle.info">
  <meta name="dc.subject" content="Mindboggle">
  <meta name="dc.type" content="text.homepage.academic"> 
  <meta name="dc.format" content="text/html"> 
  <meta name="dc.identifier" content="http://binarybottle.github.io/mindboggle/">

  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <table>
  <tr>
   <td>

 <a href="../../index.html">
  <img src="../../shared/mindboggle_logo_small.jpg" alt="small mindboggle logo"  border="0" width="160"/></a>

   </td>
   <td>
    <table>
     <tr>
 <a style="padding: 20px 20px 20px 20px; color: #b07613; text-decoration: none; font-size: 32px"
  href="../../index.html">Mindboggle</a>
     </tr>
     <tr> <td height="18"></td>
     </tr>
     <tr>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../users/README.html">Software</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../data.html">Data</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../papers.html">Papers</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../people.html">People</a>
      </td>
     </tr>
    </table>
   </td>
  </tr>
 </table>
</div>
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="utils-segment">
<h1>utils.segment<a class="headerlink" href="#utils-segment" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-mindboggle.utils.segment">
<span id="module-utils-segment"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">utils.segment</span></tt><a class="headerlink" href="#module-mindboggle.utils.segment" title="Permalink to this headline">¶</a></h2>
<p>Functions for segmenting a surface mesh.</p>
<dl class="docutils">
<dt>Authors:</dt>
<dd><ul class="first last simple">
<li>Yrjo Hame, 2012  (<a class="reference external" href="mailto:yrjo&#46;hame&#37;&#52;&#48;gmail&#46;com">yrjo<span>&#46;</span>hame<span>&#64;</span>gmail<span>&#46;</span>com</a>)</li>
<li>Arno Klein, 2012-2013  (<a class="reference external" href="mailto:arno&#37;&#52;&#48;mindboggle&#46;info">arno<span>&#64;</span>mindboggle<span>&#46;</span>info</a>)  <a class="reference external" href="http://binarybottle.com">http://binarybottle.com</a></li>
</ul>
</dd>
</dl>
<p>Copyright 2013,  Mindboggle team (<a class="reference external" href="http://mindboggle.info">http://mindboggle.info</a>), Apache v2.0 License</p>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mindboggle.utils.segment.combine_2labels_in_2volumes">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">combine_2labels_in_2volumes</tt><big>(</big><em>file1</em>, <em>file2</em>, <em>label1=3</em>, <em>label2=2</em>, <em>output_file=''</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.combine_2labels_in_2volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the voxels of one label from two files and overlay them
on the second label combined from the two files.</p>
<p>An example application is to combine two segmentation volumes,
such as from FreeSurfer and ANTs, to obtain a single cortex=2
and noncortex=3 segmentation file, by taking the union of cortex voxels
from the segmentations, the union of the noncortex voxels from the
segmentations, and overwriting intersecting cortex and noncortex voxels
with noncortex (3) labels.</p>
<p>ANTs tends to include more cortical gray matter at the periphery of
the brain than Freesurfer, and FreeSurfer tends to include more white
matter that extends deep into gyral folds than ANTs, so this function
attempts to remedy their differences by overlaying ANTs cortical gray
with FreeSurfer white matter.</p>
<p>Example preprocessing steps</p>
<div class="highlight-python"><div class="highlight"><pre>1. Run Freesurfer and antsCorticalThickness.sh on T1-weighted image.
2. Convert FreeSurfer volume labels (e.g., wmparc.mgz or aparc+aseg.mgz)
   to cortex (2) and noncortex (3) segments using relabel_volume()
   function [refer to LABELS.py or FreeSurferColorLUT labels file].
3. Convert ANTs Atropos-segmented volume (tmpBrainSegmentation.nii.gz)
   to cortex and noncortex segments, by converting 1-labels to 0 and
   4-labels to 3 with the relabel_volume() function
   (the latter is to include deep-gray matter with noncortical tissues).
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file1</strong> : string</p>
<blockquote>
<div><p>name of nibabel-readable file with labels in {label1, label2}</p>
</div></blockquote>
<p><strong>file2</strong> : string</p>
<blockquote>
<div><p>name of nibabel-readable file with labels in {label1, label2}</p>
</div></blockquote>
<p><strong>label1</strong> : integer</p>
<blockquote>
<div><p>source label number</p>
</div></blockquote>
<p><strong>label2</strong> : integer</p>
<blockquote>
<div><p>target label number (to be overwritten by label1 where they intersect)</p>
</div></blockquote>
<p><strong>output_file</strong> : string</p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output_file</strong> : string</p>
<blockquote class="last">
<div><p>name of combined segmented nibabel-readable file
with labels in {label1, label2}</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">combine_2labels_in_2volumes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file1</span> <span class="o">=</span> <span class="s">&#39;seg1.nii.gz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file2</span> <span class="o">=</span> <span class="s">&#39;seg2.nii.gz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_file</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combine_2labels_in_2volumes</span><span class="p">(</span><span class="n">file1</span><span class="p">,</span> <span class="n">file2</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">output_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.extract_borders">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">extract_borders</tt><big>(</big><em>indices</em>, <em>labels</em>, <em>neighbor_lists</em>, <em>ignore_values=[]</em>, <em>return_label_pairs=False</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.extract_borders" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the label borders in a collection of vertices such as a region.</p>
<p>Label borders are the set of all vertices
whose neighbors do not share the same label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices to (a subset of) vertices</p>
</div></blockquote>
<p><strong>labels</strong> : numpy array of integers</p>
<blockquote>
<div><p>label numbers for all vertices</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>ignore_values</strong> : list of integers</p>
<blockquote>
<div><p>integers to ignore (e.g., background)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>border_indices</strong> : list of integers</p>
<blockquote>
<div><p>indices to label boundary vertices</p>
</div></blockquote>
<p><strong>border_label_tuples</strong> : list of lists of sorted pairs of integers</p>
<blockquote>
<div><p>sorted label pairs</p>
</div></blockquote>
<p><strong>unique_border_label_tuples</strong> : list of sorted pairs of integers</p>
<blockquote class="last">
<div><p>unique, sorted label pairs</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Small example:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_borders</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="p">[],</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">    ([1, 2, 4, 5],</span>
<span class="go">     [[20, 30], [30, 40], [50, 80], [30, 40]],</span>
<span class="go">     [[20, 30], [30, 40], [50, 80]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Real example -- extract sulcus label boundaries:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;lh.labels.DKT25.manual.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">labels_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_borders</span><span class="p">,</span> <span class="n">label_pairs</span><span class="p">,</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">npoints</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">labels</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">indices_borders</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">labels_file</span><span class="p">,</span> <span class="s">&#39;extract_borders.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">IDs</span><span class="p">,</span> <span class="s">&#39;borders&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;extract_borders.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.extract_borders_2nd_surface">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">extract_borders_2nd_surface</tt><big>(</big><em>labels_file</em>, <em>mask_file=''</em>, <em>values_file=''</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.extract_borders_2nd_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract borders (between labels) on a surface.
Options: Mask out values; extract border values on a second surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels_file</strong> : string</p>
<blockquote>
<div><p>file name for surface mesh with labels</p>
</div></blockquote>
<p><strong>mask_file</strong> : string</p>
<blockquote>
<div><p>file name for surface mesh with mask (non-background) values</p>
</div></blockquote>
<p><strong>values_file</strong> : string</p>
<blockquote>
<div><p>file name for surface mesh with values to extract along borders</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>border_file</strong> : string</p>
<blockquote>
<div><p>file name for surface mesh with label borders (not background values)</p>
</div></blockquote>
<p><strong>border_values</strong> : numpy array</p>
<blockquote class="last">
<div><p>values for all vertices (background for vertices off label borders)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract depth values along label borders in sulci (mask):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders_2nd_surface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;lh.labels.DKT25.manual.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;sulci.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.travel_depth.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_file</span><span class="p">,</span> <span class="n">border_values</span> <span class="o">=</span> <span class="n">extract_borders_2nd_surface</span><span class="p">(</span><span class="n">labels_file</span><span class="p">,</span> <span class="n">mask_file</span><span class="p">,</span> <span class="n">values_file</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="n">border_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.propagate">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">propagate</tt><big>(</big><em>points</em>, <em>faces</em>, <em>region</em>, <em>seeds</em>, <em>labels</em>, <em>max_iters=500</em>, <em>tol=0.001</em>, <em>sigma=10</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate labels to segment surface into contiguous regions,
starting from seed vertices.</p>
<p>Imports : mindboggle.labels.rebound</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : array (or list) of lists of three integers</p>
<blockquote>
<div><p>coordinates for all vertices</p>
</div></blockquote>
<p><strong>faces</strong> : list of lists of three integers</p>
<blockquote>
<div><p>indices to three vertices per face (indices start from zero)</p>
</div></blockquote>
<p><strong>region</strong> : list (or array) of integers</p>
<blockquote>
<div><p>values &gt; background_value indicate inclusion in a region for all vertices</p>
</div></blockquote>
<p><strong>seeds</strong> : numpy array of integers</p>
<blockquote>
<div><p>seed numbers for all vertices</p>
</div></blockquote>
<p><strong>labels</strong> : numpy array of integers</p>
<blockquote>
<div><p>label numbers for all vertices</p>
</div></blockquote>
<p><strong>max_iters</strong> : integer</p>
<blockquote>
<div><p>maximum number of iterations to run graph-based learning algorithm</p>
</div></blockquote>
<p><strong>tol: float</strong> :</p>
<blockquote>
<div><p>threshold to assess convergence of the algorithm</p>
</div></blockquote>
<p><strong>sigma: float</strong> :</p>
<blockquote>
<div><p>gaussian kernel parameter</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>segments</strong> : numpy array of integers</p>
<blockquote class="last">
<div><p>region numbers for all vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Propagate labels between label boundary segments in a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mindboggle.labels.rebound</span> <span class="kn">as</span> <span class="nn">rb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">propagate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.LABELS</span> <span class="kn">import</span> <span class="n">DKTprotocol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dkt</span> <span class="o">=</span> <span class="n">DKTprotocol</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;lh.labels.DKT25.manual.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">labels_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_borders</span><span class="p">,</span> <span class="n">label_pairs</span><span class="p">,</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">npoints</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">labels</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_ID</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_fold</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_ID</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_array</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_array</span><span class="p">[</span><span class="n">indices_fold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract the boundary for this fold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_borders</span><span class="p">,</span> <span class="n">label_pairs</span><span class="p">,</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="n">indices_fold</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">labels</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select boundary segments in the sulcus labeling protocol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seeds</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ilist</span><span class="p">,</span><span class="n">label_pair_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dkt</span><span class="o">.</span><span class="n">sulcus_label_pair_lists</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_borders</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>         <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">label_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="ow">in</span> <span class="n">label_pair_list</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">seeds</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">ilist</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">propagate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">fold_array</span><span class="p">,</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">labels_file</span><span class="p">,</span> <span class="s">&#39;propagate.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">segments</span><span class="p">,</span> <span class="s">&#39;segments&#39;</span><span class="p">,</span> <span class="n">segments</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;propagate.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.segment">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">segment</tt><big>(</big><em>vertices_to_segment</em>, <em>neighbor_lists</em>, <em>min_region_size=1</em>, <em>seed_lists=[]</em>, <em>keep_seeding=False</em>, <em>spread_within_labels=False</em>, <em>labels=[]</em>, <em>label_lists=[]</em>, <em>values=[]</em>, <em>max_steps=''</em>, <em>verbose=False</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Segment vertices of surface into contiguous regions by seed growing,
starting from zero or more lists of seed vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices_to_segment</strong> : list of integers</p>
<blockquote>
<div><p>indices to mesh vertices to be segmented</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>min_region_size</strong> : integer</p>
<blockquote>
<div><p>minimum size of segmented set of vertices</p>
</div></blockquote>
<p><strong>seed_lists</strong> : list of lists, or empty list</p>
<blockquote>
<div><p>each list contains indices to seed vertices to segment vertices_to_segment</p>
</div></blockquote>
<p><strong>keep_seeding</strong> : Boolean</p>
<blockquote>
<div><p>grow from new seeds even after all seed lists have fully grown</p>
</div></blockquote>
<p><strong>spread_within_labels</strong> : Boolean</p>
<blockquote>
<div><p>grow seeds only by vertices with labels in the seed labels?</p>
</div></blockquote>
<p><strong>labels</strong> : list of integers (required only if spread_within_labels)</p>
<blockquote>
<div><p>label numbers for all vertices</p>
</div></blockquote>
<p><strong>label_lists</strong> : list of lists of integers (required only if spread_within_labels)</p>
<blockquote>
<div><p>List of unique labels for each seed list to grow into
(If empty, set to unique labels for each seed list)</p>
</div></blockquote>
<p><strong>values</strong> : list of floats (default empty)</p>
<blockquote>
<div><p>values for all vertices for use in preferentially directed segmentation
(segment in direction of lower values)</p>
</div></blockquote>
<p><strong>max_steps</strong> : integer (or empty string for infinity)</p>
<blockquote>
<div><p>maximum number of segmentation steps to take for each seed list</p>
</div></blockquote>
<p><strong>verbose</strong> : Boolean</p>
<blockquote>
<div><p>print out text?</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>segments</strong> : numpy array of integers</p>
<blockquote class="last">
<div><p>region numbers for all vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Segment deep regions with or without seeds:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">segment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.travel_depth.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices_to_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">depths</span> <span class="o">&gt;</span> <span class="mf">0.50</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c"># higher to speed up</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Example 1: without seed lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span> <span class="o">=</span> <span class="n">segment</span><span class="p">(</span><span class="n">vertices_to_segment</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span> <span class="s">&#39;segment.vtk&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">,</span> <span class="s">&#39;folds&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;segment.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Example 2: with seed lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.LABELS</span> <span class="kn">import</span> <span class="n">DKTprotocol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dkt</span> <span class="o">=</span> <span class="n">DKTprotocol</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dkt</span><span class="o">.</span><span class="n">sulcus_label_pair_lists</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;lh.labels.DKT25.manual.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">labels_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_borders</span><span class="p">,</span> <span class="n">label_pairs</span><span class="p">,</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="n">vertices_to_segment</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">labels</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">ignore_values</span><span class="o">=</span><span class="p">[],</span> <span class="n">return_label_pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed_lists</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">label_pair_list</span> <span class="ow">in</span> <span class="n">dkt</span><span class="o">.</span><span class="n">sulcus_label_pair_lists</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">seed_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_borders</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">label_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="ow">in</span> <span class="n">label_pair_list</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sulci</span> <span class="o">=</span> <span class="n">segment</span><span class="p">(</span><span class="n">vertices_to_segment</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">seed_lists</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">label_lists</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span> <span class="s">&#39;segment_seeds.vtk&#39;</span><span class="p">,</span> <span class="n">sulci</span><span class="p">,</span> <span class="s">&#39;sulci&#39;</span><span class="p">,</span> <span class="n">sulci</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;segment_seeds.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.segment_by_filling_borders">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">segment_by_filling_borders</tt><big>(</big><em>regions</em>, <em>neighbor_lists</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.segment_by_filling_borders" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill borders (contours) on a surface mesh
to segment vertices into contiguous regions.</p>
<dl class="docutils">
<dt>Steps ::</dt>
<dd><ol class="first last arabic">
<li><p class="first">Extract region borders (assumed to be closed contours)</p>
</li>
<li><p class="first">Segment borders into separate, contiguous borders</p>
</li>
<li><dl class="first docutils">
<dt>For each boundary</dt>
<dd><ol class="first last arabic simple" start="4">
<li>Find the neighbors to either side of the boundary</li>
<li>Segment the neighbors into exterior and interior sets of neighbors</li>
<li>Find the interior (smaller) sets of neighbors</li>
<li>Fill the contours formed by the interior neighbors</li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>regions</strong> : numpy array of integers</p>
<blockquote>
<div><p>region numbers for all vertices</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>segments</strong> : numpy array of integers</p>
<blockquote class="last">
<div><p>region numbers for all vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Segment folds by extracting their borders and filling them in separately:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">segment_by_filling_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.travel_depth.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span><span class="p">[</span><span class="n">depths</span> <span class="o">&gt;</span> <span class="mf">0.50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span> <span class="o">=</span> <span class="n">segment_by_filling_borders</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span> <span class="s">&#39;segment_by_filling_borders.vtk&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">,</span> <span class="s">&#39;folds&#39;</span><span class="p">,</span> <span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;segment_by_filling_borders.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.segment_rings">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">segment_rings</tt><big>(</big><em>region</em>, <em>seeds</em>, <em>neighbor_lists</em>, <em>step=1</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.segment_rings" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively segment a region of surface mesh as concentric segments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>region</strong> : list of integers</p>
<blockquote>
<div><p>indices of region vertices to segment (such as a fold)</p>
</div></blockquote>
<p><strong>seeds</strong> : list of integers</p>
<blockquote>
<div><p>indices of seed vertices</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>step</strong> : integer</p>
<blockquote>
<div><p>number of segmentation steps before assessing segments</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>segments</strong> : list of lists of integers</p>
<blockquote class="last">
<div><p>indices to vertices for each concentric segment</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">extract_borders</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">segment_rings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;depth_rescaled.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">values_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;fold11.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">fold_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">background_value</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Initialize seeds with the boundary of thresholded indices:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">use_threshold</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">use_threshold</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c"># Threshold at the median depth or within maximum values in boundary:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span> <span class="c">#+ np.std(values[indices])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indices_high</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c"># Make sure threshold is within the maximum values of the boundary:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">B</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">borders</span><span class="p">,</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span> <span class="n">B</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">borders</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">borders</span> <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">background_value</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">indices_high</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">borders</span><span class="p">)):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">borders</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">borders</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">indices_high</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c"># Extract threshold boundary vertices as seeds:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">B</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">B</span><span class="p">[</span><span class="n">indices_high</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">seeds</span><span class="p">,</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">extract_borders</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)),</span> <span class="n">B</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Or initialize P with the maximum value point:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">indices</span><span class="p">])]]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indices_high</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">indices_high</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">seeds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">segment_rings</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">S</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;segment_rings.vtk&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="s">&#39;segment_rings&#39;</span><span class="p">,</span> <span class="n">fold</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;segment_rings.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Store:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#import pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#output_file = os.path.join(path, &#39;tests&#39;, &#39;segments_fold11.pkl&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#pickle.dump(segments, open(output_file, &quot;wb&quot; ))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.select_largest">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">select_largest</tt><big>(</big><em>points, faces, exclude_labels=[-1], areas=None, reindex=True</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.select_largest" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the largest segment (connected set of indices) in a mesh.</p>
<p>In case a surface patch is fragmented, we select the largest fragment,
remove extraneous triangular faces, and reindex indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>points</strong> : list of lists of 3 floats</p>
<blockquote>
<div><p>x,y,z coordinates for each vertex of the structure</p>
</div></blockquote>
<p><strong>faces</strong> : list of lists of 3 integers</p>
<blockquote>
<div><p>3 indices to vertices that form a triangle on the mesh</p>
</div></blockquote>
<p><strong>exclude_labels</strong> : list of integers</p>
<blockquote>
<div><p>background values to exclude</p>
</div></blockquote>
<p><strong>areas</strong> : numpy array or list of floats (or None)</p>
<blockquote>
<div><p>surface area scalar values for all vertices</p>
</div></blockquote>
<p><strong>reindex</strong> : Boolean</p>
<blockquote>
<div><p>reindex indices in faces?</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>points</strong> : list of lists of 3 floats</p>
<blockquote>
<div><p>x,y,z coordinates for each vertex of the structure</p>
</div></blockquote>
<p><strong>faces</strong> : list of lists of 3 integers</p>
<blockquote class="last">
<div><p>3 indices to vertices that form a triangle on the mesh</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Two surface patches:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">write_vtk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">remove_faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">select_largest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;lh.labels.DKT31.manual.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.area.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exclude_labels</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span><span class="n">u3</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">label_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I28</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">28</span><span class="p">]</span> <span class="c"># superior frontal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I20</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">20</span><span class="p">]</span> <span class="c"># pars triangularis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I28</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">I20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="n">remove_faces</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">I28</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">areas</span><span class="p">,</span> <span class="n">u1</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">area_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reindex</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points2</span><span class="p">,</span> <span class="n">faces2</span> <span class="o">=</span> <span class="n">select_largest</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">exclude_labels</span><span class="p">,</span> <span class="n">areas</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                 <span class="n">reindex</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalars</span><span class="p">[</span><span class="n">I28</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="s">&#39;test_two_labels.vtk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">scalars</span><span class="p">,</span> <span class="n">scalar_names</span><span class="o">=</span><span class="s">&#39;scalars&#39;</span><span class="p">,</span> <span class="n">scalar_type</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.split_brain">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">split_brain</tt><big>(</big><em>image_file</em>, <em>label_file</em>, <em>left_labels</em>, <em>right_labels</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.split_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a brain using left/right labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image_file</strong> : string</p>
<blockquote>
<div><p>nibabel-readable image volume</p>
</div></blockquote>
<p><strong>label_file</strong> : string</p>
<blockquote>
<div><p>nibabel-readable labeled brain image volume</p>
</div></blockquote>
<p><strong>left_labels</strong> : list of integers</p>
<blockquote>
<div><p>left label numbers</p>
</div></blockquote>
<p><strong>right_labels</strong> : list of integers</p>
<blockquote>
<div><p>right label numbers</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>left_brain</strong> : string</p>
<blockquote>
<div><p>name of nibabel-readable image volume with left half of brain image</p>
</div></blockquote>
<p><strong>right_brain</strong> : string</p>
<blockquote class="last">
<div><p>name of nibabel-readable image volume with right half of brain image</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">split_brain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_volumes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.LABELS</span> <span class="kn">import</span> <span class="n">DKTprotocol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;mri&#39;</span><span class="p">,</span> <span class="s">&#39;t1weighted_brain.nii.gz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;labels.DKT25.manual.nii.gz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dkt</span> <span class="o">=</span> <span class="n">DKTprotocol</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">left_labels</span> <span class="o">=</span> <span class="n">dkt</span><span class="o">.</span><span class="n">left_label_numbers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">right_labels</span> <span class="o">=</span> <span class="n">dkt</span><span class="o">.</span><span class="n">right_label_numbers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">left_brain</span><span class="p">,</span> <span class="n">right_brain</span> <span class="o">=</span> <span class="n">split_brain</span><span class="p">(</span><span class="n">image_file</span><span class="p">,</span> <span class="n">label_file</span><span class="p">,</span> <span class="n">left_labels</span><span class="p">,</span> <span class="n">right_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_volumes</span><span class="p">([</span><span class="n">left_brain</span><span class="p">,</span> <span class="n">right_brain</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.segment.watershed">
<tt class="descclassname">mindboggle.utils.segment.</tt><tt class="descname">watershed</tt><big>(</big><em>depths</em>, <em>points</em>, <em>indices</em>, <em>neighbor_lists</em>, <em>min_size=1</em>, <em>depth_factor=0.25</em>, <em>depth_ratio=0.1</em>, <em>tolerance=0.01</em>, <em>regrow=True</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.segment.watershed" title="Permalink to this definition">¶</a></dt>
<dd><p>Segment vertices of a surface mesh into contiguous &#8220;watershed basins&#8221;
by seed growing from an iterative selection of the deepest vertices.</p>
<p>Steps</p>
<div class="highlight-python"><div class="highlight"><pre>1. Grow segments from an iterative selection of the deepest seeds.
2. Regrow segments from the resulting seeds, until each seed&#39;s
    segment touches a boundary.
3. Use the segment() function to fill in the rest.
4. Merge segments if their seeds are too close to each other
    or their depths are very different.
</pre></div>
</div>
<p>Note</p>
<div class="highlight-python"><div class="highlight"><pre>Despite the above precautions, the order of seed selection in segment()
could possibly influence the resulting borders between adjoining
segments (vs. propagate(), which is slower and insensitive to depth,
but is not biased by seed order).
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>depths</strong> : numpy array of floats</p>
<blockquote>
<div><p>depth values for all vertices</p>
</div></blockquote>
<p><strong>points</strong> : list of lists of floats</p>
<blockquote>
<div><p>each element is a list of 3-D coordinates of a vertex on a surface mesh</p>
</div></blockquote>
<p><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices to mesh vertices to be segmented</p>
</div></blockquote>
<p><strong>min_size</strong> : index</p>
<blockquote>
<div><p>the minimum number of vertices in a basin</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>depth_factor</strong> : float</p>
<blockquote>
<div><p>factor to determine whether to merge two neighboring watershed catchment
basins &#8211; they are merged if the Euclidean distance between their basin
seeds is less than this fraction of the maximum Euclidean distance
between points having minimum and maximum depths</p>
</div></blockquote>
<p><strong>depth_ratio</strong> : float</p>
<blockquote>
<div><p>the minimum fraction of depth for a neighboring shallower
watershed catchment basin (otherwise merged with the deeper basin)</p>
</div></blockquote>
<p><strong>tolerance</strong> : float</p>
<blockquote>
<div><p>tolerance for detecting differences in depth between vertices</p>
</div></blockquote>
<p><strong>regrow</strong> : Boolean</p>
<blockquote>
<div><p>regrow segments from watershed seeds?</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>segments</strong> : list of integers</p>
<blockquote>
<div><p>region numbers for all vertices</p>
</div></blockquote>
<p><strong>seed_indices</strong> : list of integers</p>
<blockquote class="last">
<div><p>list of indices to seed vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Perform watershed segmentation on the deeper portions of a surface:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.segment</span> <span class="kn">import</span> <span class="n">watershed</span><span class="p">,</span> <span class="n">segment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;shapes&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.travel_depth.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">depths</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># high to speed up</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth_factor</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depth_ratio</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regrow</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span><span class="p">,</span> <span class="n">seed_indices</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">depths</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indices</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth_factor</span><span class="p">,</span> <span class="n">depth_ratio</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">tolerance</span><span class="p">,</span> <span class="n">regrow</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span> <span class="s">&#39;watershed.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">segments</span><span class="p">,</span> <span class="s">&#39;segments&#39;</span><span class="p">,</span> <span class="n">segments</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;watershed.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View watershed seeds:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seeds</span> <span class="o">=</span> <span class="n">background_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">depths</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seed_indices</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">seeds</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">depth_file</span><span class="p">,</span> <span class="s">&#39;watershed_seeds.vtk&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">seeds</span><span class="p">,</span> <span class="s">&#39;seeds&#39;</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;watershed_seeds.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
<!-- Google Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-693862-13");
pageTracker._trackPageview();
} catch(err) {}
</script>

  </body>
</html>