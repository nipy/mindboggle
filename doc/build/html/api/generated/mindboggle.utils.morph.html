<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mindboggle &mdash; Mindboggle</title>
    
    <link rel="stylesheet" href="../../_static/mindboggle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Mindboggle" href="../../index.html" />
  <HTML><head><title>Mindboggle</title>
  <meta http-equiv="Content-language" content="en">
  <meta name="description" content="Mindboggle">
  <meta name="keywords" content="Mindboggle, neuroimaging, brain imaging, python, neuroscience, labeling, parcellation, morphometry, shape analysis, MRI">
  <meta name="author" content="mailto:arno&#64;mindboggle.info">
  <meta name="dc.title" content="Mindboggle"> 
  <meta name="dc.creator.address" content="arno&#64;mindboggle.info">
  <meta name="dc.subject" content="Mindboggle">
  <meta name="dc.type" content="text.homepage.academic"> 
  <meta name="dc.format" content="text/html"> 
  <meta name="dc.identifier" content="http://binarybottle.github.io/mindboggle/">

  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <table>
  <tr>
   <td>

 <a href="../../index.html">
  <img src="../../shared/mindboggle_logo_small.jpg" alt="small mindboggle logo"  border="0" width="160"/></a>

   </td>
   <td>
    <table>
     <tr>
 <a style="padding: 20px 20px 20px 20px; color: #b07613; text-decoration: none; font-size: 32px"
  href="../../index.html">Mindboggle</a>
     </tr>
     <tr> <td height="18"></td>
     </tr>
     <tr>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="http://www.mindboggle.info/users/README.html">Software</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../data.html">Data</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../papers.html">Papers</a>
      </td>
      <td>
  <a style="padding: 20px 20px 20px 20px; text-decoration: none; font-size: 18px"
   href="../../people.html">People</a>
      </td>
     </tr>
    </table>
   </td>
  </tr>
 </table>
</div>
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="utils-morph">
<h1>utils.morph<a class="headerlink" href="#utils-morph" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-mindboggle.utils.morph">
<span id="module-utils-morph"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">utils.morph</span></tt><a class="headerlink" href="#module-mindboggle.utils.morph" title="Permalink to this headline">¶</a></h2>
<p>Morphological image operations on surface mesh vertices.</p>
<dl class="docutils">
<dt>Authors:</dt>
<dd><ul class="first last simple">
<li>Arno Klein, 2012-2013  (<a class="reference external" href="mailto:arno&#37;&#52;&#48;mindboggle&#46;info">arno<span>&#64;</span>mindboggle<span>&#46;</span>info</a>)  <a class="reference external" href="http://binarybottle.com">http://binarybottle.com</a></li>
<li>Yrjo Hame, 2012  (<a class="reference external" href="mailto:yrjo&#46;hame&#37;&#52;&#48;gmail&#46;com">yrjo<span>&#46;</span>hame<span>&#64;</span>gmail<span>&#46;</span>com</a>)</li>
</ul>
</dd>
</dl>
<p>Copyright 2013,  Mindboggle team (<a class="reference external" href="http://mindboggle.info">http://mindboggle.info</a>), Apache v2.0 License</p>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mindboggle.utils.morph.close_surface_pair">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">close_surface_pair</tt><big>(</big><em>faces</em>, <em>points1</em>, <em>points2</em>, <em>scalars</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.close_surface_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a surface patch by connecting its border vertices with
corresponding vertices in a second surface file.</p>
<p>Assumes no lines or indices when reading VTK files in.</p>
<p>Note</p>
<div class="highlight-python"><div class="highlight"><pre>Scalar values different than background define the surface patch.
The two sets of points have a 1-to-1 mapping; they are from
two surfaces whose corresponding vertices are shifted in position.
For pial vs. gray-white matter, the two surfaces are not parallel,
so connecting the vertices leads to intersecting faces.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>faces</strong> : list of lists of integers</p>
<blockquote>
<div><p>each sublist contains 3 indices of vertices that form a face
on a surface mesh</p>
</div></blockquote>
<p><strong>points1</strong> : list of lists of floats</p>
<blockquote>
<div><p>each sublist contains 3-D coordinates of a vertex on a surface mesh</p>
</div></blockquote>
<p><strong>points2</strong> : list of lists of floats</p>
<blockquote>
<div><p>points from second surface with 1-to-1 correspondence with points1</p>
</div></blockquote>
<p><strong>scalars</strong> : numpy array of integers</p>
<blockquote>
<div><p>labels used to find foreground vertices</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>scalar value for background vertices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>closed_faces</strong> : list of lists of integers</p>
<blockquote>
<div><p>indices of vertices that form a face on the closed surface mesh</p>
</div></blockquote>
<p><strong>closed_points</strong> : list of lists of floats</p>
<blockquote>
<div><p>3-D coordinates from points1 and points2</p>
</div></blockquote>
<p><strong>closed_scalars</strong> : list of integers</p>
<blockquote class="last">
<div><p>scalar values for points1 and points2</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Example 1: build a cube by closing two parallel planes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">close_surface_pair</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">write_vtk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Build plane:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c"># plane edge length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points1</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">points1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">points1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="n">background_value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points1</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">scalars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#write_vtk(&#39;plane.vtk&#39;, points1, [], [], faces, scalars)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#plot_surfaces(&#39;plane.vtk&#39;) </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closed_faces</span><span class="p">,</span> <span class="n">closed_points</span><span class="p">,</span> <span class="n">closed_scalars</span> <span class="o">=</span> <span class="n">close_surface_pair</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="s">&#39;cube.vtk&#39;</span><span class="p">,</span> <span class="n">closed_points</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">closed_faces</span><span class="p">,</span> <span class="n">closed_scalars</span><span class="p">,</span> <span class="s">&#39;int&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;cube.vtk&#39;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Example 2: Gray and white cortical brain surfaces:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">close_surface_pair</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">read_points</span><span class="p">,</span> <span class="n">write_vtk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patch_surface1</span> <span class="o">=</span> <span class="s">&#39;fold.pial.vtk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">whole_surface2</span> <span class="o">=</span> <span class="s">&#39;fold.white.vtk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points1</span> <span class="o">=</span> <span class="n">read_points</span><span class="p">(</span><span class="n">folds_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalars</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalars</span><span class="p">[</span><span class="n">scalars</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_surface</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.white.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">u3</span><span class="p">,</span> <span class="n">u4</span><span class="p">,</span> <span class="n">u5</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">white_surface</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closed_faces</span><span class="p">,</span> <span class="n">closed_points</span><span class="p">,</span> <span class="n">closed_scalars</span> <span class="o">=</span> <span class="n">close_surface_pair</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="s">&#39;closed.vtk&#39;</span><span class="p">,</span> <span class="n">closed_points</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">closed_faces</span><span class="p">,</span> <span class="n">closed_scalars</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">&#39;int&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;closed.vtk&#39;</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.morph.close_surface_pair_from_files">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">close_surface_pair_from_files</tt><big>(</big><em>patch_surface1</em>, <em>whole_surface2</em>, <em>background_value=-1</em>, <em>output_vtk=''</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.close_surface_pair_from_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a surface patch by connecting its border vertices with
corresponding vertices in a second surface file.</p>
<p>Assumes no lines or indices when reading VTK files in.</p>
<p>Note</p>
<div class="highlight-python"><div class="highlight"><pre>The first VTK file contains scalar values different than background
for a surface patch.  The second VTK file contains the (entire)
surface whose corresponding vertices are shifted in position.
For pial vs. gray-white matter, the two surfaces are not parallel,
so connecting the vertices leads to intersecting faces.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>patch_surface1</strong> : string</p>
<blockquote>
<div><p>vtk file with surface patch of non-background scalar values</p>
</div></blockquote>
<p><strong>whole_surface2</strong> : string</p>
<blockquote>
<div><p>second vtk file with 1-to-1 vertex correspondence with patch_surface1
(whole surface so as to derive vertex neighbor lists)</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>scalar value for background vertices</p>
</div></blockquote>
<p><strong>output_vtk</strong> : string</p>
<blockquote>
<div><p>output vtk file name with closed surface patch</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output_vtk</strong> : string</p>
<blockquote class="last">
<div><p>output vtk file name with closed surface patch</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">close_surface_pair_from_files</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">read_points</span><span class="p">,</span> <span class="n">write_vtk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patch_surface1</span> <span class="o">=</span> <span class="s">&#39;fold.pial.vtk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">whole_surface2</span> <span class="o">=</span> <span class="s">&#39;fold.white.vtk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">read_points</span><span class="p">(</span><span class="n">folds_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">folds</span> <span class="o">!=</span> <span class="n">fold_number</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_surface</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.white.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">u3</span><span class="p">,</span> <span class="n">u4</span><span class="p">,</span> <span class="n">u5</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">white_surface</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="n">patch_surface1</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">faces</span><span class="p">,</span> <span class="n">folds</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="n">whole_surface2</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">faces</span><span class="p">,</span> <span class="n">folds</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_vtk</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">close_surface_pair_from_files</span><span class="p">(</span><span class="n">patch_surface1</span><span class="p">,</span> <span class="n">whole_surface2</span><span class="p">,</span> <span class="n">background_value</span><span class="p">,</span> <span class="n">output_vtk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># View:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;closed.vtk&#39;</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.morph.dilate">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">dilate</tt><big>(</big><em>indices</em>, <em>nedges</em>, <em>neighbor_lists</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.dilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Dilate region on a surface mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices to dilate</p>
</div></blockquote>
<p><strong>nedges</strong> : integer</p>
<blockquote>
<div><p>number of edges to dilate across</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dilated_indices</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices of original vertices with dilated vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">dilate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nedges</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span> <span class="c">#11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dilated_indices</span> <span class="o">=</span> <span class="n">dilate</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nedges</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">dilated_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;dilate.vtk&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">,</span> <span class="s">&#39;dilated_fold&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;dilate.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.morph.erode">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">erode</tt><big>(</big><em>indices</em>, <em>nedges</em>, <em>neighbor_lists</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.erode" title="Permalink to this definition">¶</a></dt>
<dd><p>Erode region on a surface mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices to erode</p>
</div></blockquote>
<p><strong>nedges</strong> : integer</p>
<blockquote>
<div><p>number of edges to erode across</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eroded_indices</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices of original vertices without eroded vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">erode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nedges</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span> <span class="c">#11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eroded_indices</span> <span class="o">=</span> <span class="n">erode</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nedges</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">eroded_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;erode.vtk&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">,</span> <span class="s">&#39;eroded_fold&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;erode.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.morph.extract_edge">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">extract_edge</tt><big>(</big><em>indices</em>, <em>neighbor_lists</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.extract_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Erode region on a surface mesh to extract the region&#8217;s edge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> : list of integers</p>
<blockquote>
<div><p>indices of vertices to erode</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>edge_indices</strong> : list of integers</p>
<blockquote class="last">
<div><p>indices of eroded vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors_from_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">extract_edge</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">rewrite_scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors_from_file</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select a single fold:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fold_number</span> <span class="o">=</span> <span class="mi">11</span> <span class="c">#11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fold_number</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edge_indices</span> <span class="o">=</span> <span class="n">extract_edge</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IDs</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rewrite_scalars</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span> <span class="s">&#39;extract_edge.vtk&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">,</span> <span class="s">&#39;edge&#39;</span><span class="p">,</span> <span class="n">IDs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;extract_edge.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.morph.fill_holes">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">fill_holes</tt><big>(</big><em>regions</em>, <em>neighbor_lists</em>, <em>values=[]</em>, <em>exclude_range=[]</em>, <em>background_value=-1</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill holes in regions on a surface mesh by using region boundaries.</p>
<p>NOTE: assumes one set of connected vertices per region</p>
<p>Steps</p>
<div class="highlight-python"><div class="highlight"><pre>1. Segment region vertex neighbors into connected vertices (region boundaries).
2. Remove the largest region boundary, presumably the
   outer contour of the region, leaving smaller boundaries,
   presumably the contours of holes within the region.
3. Call label_holes() to fill holes with surrounding region numbers.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>regions</strong> : numpy array of integers</p>
<blockquote>
<div><p>region numbers for all vertices</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
<p><strong>values</strong> : list of integers</p>
<blockquote>
<div><p>values for vertices, for use in determining which holes to remove</p>
</div></blockquote>
<p><strong>exclude_range</strong> : list of two floats</p>
<blockquote>
<div><p>hole is not filled if it contains values within this range
(prevents cases where surface connected by folds mistaken for holes)</p>
</div></blockquote>
<p><strong>background_value</strong> : integer</p>
<blockquote>
<div><p>background value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>regions</strong> : numpy array of integers</p>
<blockquote class="last">
<div><p>region numbers for all vertices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.mesh</span> <span class="kn">import</span> <span class="n">find_neighbors</span><span class="p">,</span> <span class="n">remove_faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.morph</span> <span class="kn">import</span> <span class="n">fill_holes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.io_vtk</span> <span class="kn">import</span> <span class="n">read_scalars</span><span class="p">,</span> <span class="n">read_vtk</span><span class="p">,</span> <span class="n">write_vtk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;MINDBOGGLE_DATA&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select one fold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;features&#39;</span><span class="p">,</span> <span class="s">&#39;folds.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">read_scalars</span><span class="p">(</span><span class="n">folds_file</span><span class="p">,</span> <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vtk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;arno&#39;</span><span class="p">,</span> <span class="s">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s">&#39;lh.pial.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">input_vtk</span> <span class="o">=</span> <span class="n">read_vtk</span><span class="p">(</span><span class="n">vtk_file</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">return_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_array</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_lists</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_fold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">folds</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">folds</span> <span class="o">!=</span> <span class="n">n_fold</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Make two holes in fold (background value and excluded values)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Hole 1:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Find a vertex whose removal (with its neighbors) would create a hole</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">folds</span><span class="o">==</span><span class="n">n_fold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index1</span> <span class="ow">in</span> <span class="n">I</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">N1</span> <span class="o">=</span> <span class="n">neighbor_lists</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">N1</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">folds</span><span class="p">[</span><span class="n">neighbor_lists</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">==</span> <span class="n">background_value</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">neighbor_lists</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">folds</span><span class="p">[</span><span class="n">neighbor_lists</span><span class="p">[</span><span class="n">f</span><span class="p">]]</span> <span class="o">==</span> <span class="n">background_value</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>                    <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">&gt;&gt;&gt; </span>                    <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">stop</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">N1</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Hole 2:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">folds</span><span class="o">==</span><span class="n">n_fold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index2</span> <span class="ow">in</span> <span class="n">I</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">N2</span> <span class="o">=</span> <span class="n">neighbor_lists</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">N2</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">folds</span><span class="p">[</span><span class="n">neighbor_lists</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">==</span> <span class="n">background_value</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">neighbor_lists</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">folds</span><span class="p">[</span><span class="n">neighbor_lists</span><span class="p">[</span><span class="n">f</span><span class="p">]]</span> <span class="o">==</span> <span class="n">background_value</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>                    <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">&gt;&gt;&gt; </span>                    <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">stop</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">folds</span><span class="p">[</span><span class="n">N2</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folds</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="p">[</span><span class="n">N2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write holes to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">holes</span> <span class="o">=</span> <span class="n">folds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">holes</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">holes</span><span class="p">[</span><span class="n">N1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">holes</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">holes</span><span class="p">[</span><span class="n">N2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">holes</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">background_value</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="s">&#39;holes.vtk&#39;</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">remove_faces</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">indices</span><span class="p">),</span> <span class="p">[</span><span class="n">holes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span> <span class="p">[</span><span class="s">&#39;holes&#39;</span><span class="p">],</span> <span class="s">&#39;int&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;holes.vtk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Fill Hole 1 but not Hole 2:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># (because values has an excluded value in the hole)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exclude_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">99</span><span class="p">,</span><span class="mi">101</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span> <span class="o">=</span> <span class="n">fill_holes</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">neighbor_lists</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">exclude_range</span><span class="p">,</span> <span class="n">background_value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Write results to vtk file and view:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">background_value</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_vtk</span><span class="p">(</span><span class="s">&#39;fill_holes.vtk&#39;</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">remove_faces</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">indices</span><span class="p">),</span> <span class="n">regions</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s">&#39;regions&#39;</span><span class="p">,</span> <span class="s">&#39;int&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mindboggle.utils.plots</span> <span class="kn">import</span> <span class="n">plot_surfaces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_surfaces</span><span class="p">(</span><span class="s">&#39;fill_holes.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mindboggle.utils.morph.topo_test">
<tt class="descclassname">mindboggle.utils.morph.</tt><tt class="descname">topo_test</tt><big>(</big><em>index</em>, <em>values</em>, <em>neighbor_lists</em><big>)</big><a class="headerlink" href="#mindboggle.utils.morph.topo_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Test to see if vertex is a &#8220;simple point&#8221;.</p>
<p>A simple point is a vertex that when added to or removed from an object
(e.g., a curve) on a surface mesh does not alter the object&#8217;s topology.</p>
<p>&#8220;Simple&#8221; is not to be mistaken with the following usage:
&#8220;A vertex is usually assigned one of five possible classifications:
simple, complex, boundary, interior edge, or corner vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : integer</p>
<blockquote>
<div><p>index of vertex</p>
</div></blockquote>
<p><strong>values</strong> : numpy array of integers or floats</p>
<blockquote>
<div><p>values for all vertices</p>
</div></blockquote>
<p><strong>neighbor_lists</strong> : list of lists of integers</p>
<blockquote>
<div><p>each list contains indices to neighboring vertices for each vertex</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sp</strong> : Boolean</p>
<blockquote>
<div><p>simple point or not?</p>
</div></blockquote>
<p><strong>n_inside</strong> : integer</p>
<blockquote class="last">
<div><p>number of neighboring vertices with a value greater than threshold</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
<!-- Google Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-693862-13");
pageTracker._trackPageview();
} catch(err) {}
</script>

  </body>
</html>